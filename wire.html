<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mesh e Wireframe normalizzati</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<style>
  body { margin: 0; overflow: hidden; }
  #toggleBtn {
    position: absolute;
    top: 10px; right: 10px;
    z-index: 10;
    padding: 8px 12px;
    background: rgba(255,255,255,0.3);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    color: black;
  }
</style>
</head>
<body>

<button id="toggleBtn">Mostra Wireframe</button>

<script>
let scene, camera, renderer, controls;
let meshTexturedGroup = null;
let wireframeGroup = null;
let showingWireframe = false;

const loader = new THREE.GLTFLoader();
const modelPath = 'modelli/elettronica/roland_tr-909.glb';

init();
loadMesh();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 5);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.3;
        controls.enableDamping = false;

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 7);
  scene.add(light);

  window.addEventListener('resize', onResize);

  document.getElementById('toggleBtn').addEventListener('click', () => {
    showingWireframe = !showingWireframe;
    updateVisibility();
    document.getElementById('toggleBtn').textContent = showingWireframe ? 'Mostra Texture' : 'Mostra Wireframe';
  });
}

function loadMesh() {
  loader.load(modelPath, gltf => {
    if(meshTexturedGroup) scene.remove(meshTexturedGroup);
    if(wireframeGroup) scene.remove(wireframeGroup);

    const root = gltf.scene;

    // Calcola centro e scala per normalizzare
    const box = new THREE.Box3().setFromObject(root);
    const sphere = box.getBoundingSphere(new THREE.Sphere());
    const center = sphere.center;
    const radius = sphere.radius;
    const scale = 2 / radius;

    // Normalizza root mesh (applica pos e scala)
    root.position.sub(center);
    root.scale.setScalar(scale);

    meshTexturedGroup = new THREE.Group();
    wireframeGroup = new THREE.Group();

    root.updateMatrixWorld(true); // importante!

    root.traverse(child => {
      if(child.isMesh){
        // Mesh texturizzata (clone geometria e materiale)
        const geom = child.geometry.clone();
        const mat = child.material.clone();

        // Applicare la trasformazione di scala e posizione sul vertice (bake)
        bakeGeometryTransforms(geom, child.matrixWorld);

        const mesh = new THREE.Mesh(geom, mat);
        meshTexturedGroup.add(mesh);

        // Wireframe manuale (vertici + linee)
        addWireframeManual(wireframeGroup, geom);
      }
    });

    scene.add(meshTexturedGroup);
    scene.add(wireframeGroup);

    wireframeGroup.visible = false;
    updateVisibility();
  });
}

// Funzione per applicare bake di trasformazioni sulla geometria (pos, rot, scale)
function bakeGeometryTransforms(geometry, matrixWorld){
  geometry.applyMatrix4(matrixWorld);
}

// Crea punti e linee manuali (wireframe) dati la geometria (gi√† in spazio mondo normalizzato)
function addWireframeManual(parentGroup, geometry) {
  const posAttr = geometry.attributes.position;
  const indexAttr = geometry.index;

  if(!posAttr) return;

  // Punti
  const pointsGeo = new THREE.BufferGeometry();
  const pointsPositions = new Float32Array(posAttr.count * 3);
  for(let i=0; i<posAttr.count; i++){
    pointsPositions[i*3] = posAttr.getX(i);
    pointsPositions[i*3+1] = posAttr.getY(i);
    pointsPositions[i*3+2] = posAttr.getZ(i);
  }
  pointsGeo.setAttribute('position', new THREE.BufferAttribute(pointsPositions, 3));
  const pointsMat = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.001 });
  const points = new THREE.Points(pointsGeo, pointsMat);
  parentGroup.add(points);

  // Linee bordi facce
  if(!indexAttr) return;

  const linesPositions = [];
  for(let i=0; i<indexAttr.count; i+=3){
    const a = indexAttr.getX(i);
    const b = indexAttr.getX(i+1);
    const c = indexAttr.getX(i+2);
    // Linea ab
    linesPositions.push(posAttr.getX(a), posAttr.getY(a), posAttr.getZ(a));
    linesPositions.push(posAttr.getX(b), posAttr.getY(b), posAttr.getZ(b));
    // Linea bc
    linesPositions.push(posAttr.getX(b), posAttr.getY(b), posAttr.getZ(b));
    linesPositions.push(posAttr.getX(c), posAttr.getY(c), posAttr.getZ(c));
    // Linea ca
    linesPositions.push(posAttr.getX(c), posAttr.getY(c), posAttr.getZ(c));
    linesPositions.push(posAttr.getX(a), posAttr.getY(a), posAttr.getZ(a));
  }

  const lineGeo = new THREE.BufferGeometry();
  lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linesPositions, 3));
  const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
  const lines = new THREE.LineSegments(lineGeo, lineMat);
  parentGroup.add(lines);
}



function updateVisibility(){
  if(meshTexturedGroup) meshTexturedGroup.visible = !showingWireframe;
  if(wireframeGroup) wireframeGroup.visible = showingWireframe;
}

function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
