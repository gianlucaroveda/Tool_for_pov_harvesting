<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visualizzatore Mesh 3D</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #tracker {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #00ff00;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 5px;
      z-index: 1;
      white-space: pre;
    }
/*Bottoni*/
     #buttons {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      z-index: 2;
    }
    .nav-btn {
      padding: 10px 20px;
      margin: 0 10px;
      font-size: 18px;
      cursor: pointer;
      background: rgba(0,0,0,0.6);
      color: #00ff00;
      border: none;
      border-radius: 5px;
    }

    #overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #00ff00;
      padding: 15px 20px;
      font-family: sans-serif;
      font-size: 16px;
      border-radius: 5px;
      max-width: 80%;
      z-index: 2;
      display: none;
    }
  </style>
</head>
<body>
  <div id="tracker">Caricamento...</div>

  <div id="overlay"></div>
  <div id="buttons">
    <button id="prevBtn" class="nav-btn">←</button>
    <button id="nextBtn" class="nav-btn">→</button>
  </div>

    <script>
    let scene, camera, renderer, controls;
    let gridLines, gridColorAttr;
    const gridSize = 100;
    const gridDivisions = 100;
    const gridStep = gridSize / gridDivisions;
//step
    let cameraTarget = new THREE.Vector3();  // target attuale
    let targetTweenObj = { x: 0, y: 0, z: 0 };  // oggetto usato per tweening



    // Lista di step con testo, posizione camera e punto da guardare
    const steps = [
      {
        text: 'Vista 1: Inizio.',
        position: { x: 0, y: 5, z: 6 },
        target:   { x: 0, y: 1, z: 1 }
      },
      {
        text: 'Vista 2: Primo dettaglio.',
        position: { x: 2, y: 2, z: 4 },
        target:   { x: 4, y: 1, z: 0 }
      },
      {
        text: 'Vista 3: Retro del modello.',
        position: { x: 0, y: 2, z: -5 },
        target:   { x: 0, y: 1, z: 0 }
      }
    ];
    let currentIndex = 0;

    init();
    animate();

    document.getElementById('prevBtn').addEventListener('click', () => {
      currentIndex = (currentIndex - 1 + steps.length) % steps.length;
      applyStep(currentIndex);
    });

    document.getElementById('nextBtn').addEventListener('click', () => {
      currentIndex = (currentIndex + 1) % steps.length;
      applyStep(currentIndex);
    });

    function showCaption() {
      overlay.textContent = captions[captionIndex];
      overlay.style.display = 'block';
      
    }


    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 3, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Luci
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(5, 10, 5);
      scene.add(light);

      // Controlli
      //controls = new THREE.OrbitControls(camera, renderer.domElement);
      //controls.enableDamping = true;

      // Griglia personalizzata come LineSegments
      const gridVertices = [];
      const gridColors = [];

      for (let i = -gridSize / 2; i <= gridSize / 2; i += gridStep) {
        // linee parallele all'asse X
        gridVertices.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
        // linee parallele all'asse Z
        gridVertices.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);

        // Colori iniziali (verde scuro)
        for (let j = 0; j < 2; j++) {
          gridColors.push(0, 0.2, 0);
          gridColors.push(0, 0.2, 0);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices, 3));
      gridColorAttr = new THREE.Float32BufferAttribute(gridColors, 3);
      geometry.setAttribute('color', gridColorAttr);

      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      gridLines = new THREE.LineSegments(geometry, material);
      scene.add(gridLines);

      // Caricamento modello
      const loader = new THREE.GLTFLoader();
      loader.load(
        'modelli/statue/granite_head_of_amenemhat_iii.glb',
        function (gltf) {
          scene.add(gltf.scene);
        },
        undefined,
        function (error) {
          console.error('Errore nel caricamento del modello:', error);
        }
      );
        applyStep(currentIndex); // mostra il primo step
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    //STEPS

function applyStep(index) {
  const step = steps[index];
  overlay.textContent = step.text;
  overlay.style.display = 'block';

  // Tween posizione camera
  new TWEEN.Tween(camera.position)
    .to(step.position, 1500)
    .easing(TWEEN.Easing.Quadratic.InOut)
    .start();

  // Tween target camera
  new TWEEN.Tween(targetTweenObj)
    .to(step.target, 1500)
    .easing(TWEEN.Easing.Quadratic.InOut)
    .onUpdate(() => {
      cameraTarget.set(targetTweenObj.x, targetTweenObj.y, targetTweenObj.z);
    })
    .start();
}

    function animate(time) {
      requestAnimationFrame(animate);
      //controls.update();
   
      // Calcola la posizione del fascio
      const times = Date.now() * 0.0005;
      const beamZ = Math.sin(times) * (gridSize / 2);
      
      // Aggiorna i colori delle linee in base alla distanza dal fascio
      const pos = gridLines.geometry.attributes.position.array;
      const col = gridColorAttr.array;
      for (let i = 0; i < pos.length; i += 6) {
        // ogni segmento: 2 punti = 6 valori
        const z1 = pos[i + 2];
        const z2 = pos[i + 5];
        const avgZ = (z1 + z2) / 2;
        const dist = Math.abs(avgZ - beamZ);

        const intensity = Math.max(0, 1 - dist * 20); // più vicino = più luminoso
        const green = 0.2 + 0.8 * intensity;

        for (let j = 0; j < 2; j++) {
          col[i + j * 3] = 0;
          col[i + j * 3 + 1] = green;
          col[i + j * 3 + 2] = 0;
        }
      }

      gridColorAttr.needsUpdate = true;


     // Calcolo POV, direzione e upVector
      const posi = camera.position;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const up = camera.up;

      tracker.textContent =
        `camera.position:  (${posi.x.toFixed(2)}, ${posi.y.toFixed(2)}, ${posi.z.toFixed(2)})\n` +
        `view direction:   (${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})\n` +
        `camera.up:        (${up.x.toFixed(2)}, ${up.y.toFixed(2)}, ${up.z.toFixed(2)})`;

      //steps
        TWEEN.update(time);
        camera.lookAt(cameraTarget);

      renderer.render(scene, camera);
      
    }
  </script>
</body>
</html>