<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visualizzatore Mesh 3D</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #tracker {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #00ff00;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 5px;
      z-index: 1;
      white-space: pre;
    }

  </style>
</head>
<body>
  <div id="tracker">Caricamento...</div>


    <script>
    let scene, camera, renderer, controls;
    let gridLines, gridColorAttr;
    const gridSize = 100;
    const gridDivisions = 100;
    const gridStep = gridSize / gridDivisions;

    init();
    animate();




    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 3, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Luci
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const light = new THREE.DirectionalLight(0xffffff, 0.8);
      light.position.set(5, 10, 5);
      scene.add(light);

      // Controlli
      controls = new THREE.OrbitControls(camera, renderer.domElement);

  
        // Imposta la velocità di rotazione (default 1.0)
        controls.rotateSpeed = 1.0;

        // Imposta la velocità dello zoom (default 1.2)
        controls.zoomSpeed = 1.2;

        // Imposta la velocità del pan (default 0.3)
        controls.panSpeed = 0.3;

        // Mantieni damping se vuoi animazioni più fluide
        controls.enableDamping = false;

      // Griglia personalizzata come LineSegments
      const gridVertices = [];
      const gridColors = [];

      for (let i = -gridSize / 2; i <= gridSize / 2; i += gridStep) {
        // linee parallele all'asse X
        gridVertices.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
        // linee parallele all'asse Z
        gridVertices.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);

        // Colori iniziali (verde scuro)
        for (let j = 0; j < 2; j++) {
          gridColors.push(0, 0.2, 0);
          gridColors.push(0, 0.2, 0);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices, 3));
      gridColorAttr = new THREE.Float32BufferAttribute(gridColors, 3);
      geometry.setAttribute('color', gridColorAttr);

      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      gridLines = new THREE.LineSegments(geometry, material);
      scene.add(gridLines);

      // Caricamento modello
      const loader = new THREE.GLTFLoader();
      loader.load(
        'modelli/statue/granite_head_of_amenemhat_iii.glb',
        function (gltf) {
          scene.add(gltf.scene);
        },
        undefined,
        function (error) {
          console.error('Errore nel caricamento del modello:', error);
        }
      );

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

   

    function animate(time) {
      requestAnimationFrame(animate);
      //controls.update();
   
      // Calcola la posizione del fascio
      const times = Date.now() * 0.0005;
      const beamZ = Math.sin(times) * (gridSize / 2);
      
      // Aggiorna i colori delle linee in base alla distanza dal fascio
      const pos = gridLines.geometry.attributes.position.array;
      const col = gridColorAttr.array;
      for (let i = 0; i < pos.length; i += 6) {
        // ogni segmento: 2 punti = 6 valori
        const z1 = pos[i + 2];
        const z2 = pos[i + 5];
        const avgZ = (z1 + z2) / 2;
        const dist = Math.abs(avgZ - beamZ);

        const intensity = Math.max(0, 1 - dist * 20); // più vicino = più luminoso
        const green = 0.2 + 0.8 * intensity;

        for (let j = 0; j < 2; j++) {
          col[i + j * 3] = 0;
          col[i + j * 3 + 1] = green;
          col[i + j * 3 + 2] = 0;
        }
      }

      gridColorAttr.needsUpdate = true;


     // Calcolo POV, direzione e upVector
      const posi = camera.position;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const up = camera.up;

      tracker.textContent =
        `camera.position:  (${posi.x.toFixed(2)}, ${posi.y.toFixed(2)}, ${posi.z.toFixed(2)})\n` +
        `view direction:   (${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})\n` +
        `camera.up:        (${up.x.toFixed(2)}, ${up.y.toFixed(2)}, ${up.z.toFixed(2)})`;



      renderer.render(scene, camera);
      
    }
  </script>
</body>
</html>