<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>POV Viewer</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/TrackballControls.js"></script>
<script type="module">

    const loader = new THREE.GLTFLoader();
        let currentMesh = null;
let currentMeshName = ""; 

const params = new URLSearchParams(window.location.search);
const meshUrl = decodeURIComponent(params.get("mesh"));
const meshName = params.get("name") || "unknown";

const pov = new THREE.Vector3(
  +params.get("pov_x"), +params.get("pov_y"), +params.get("pov_z")
);
const dir = new THREE.Vector3(
  +params.get("dir_x"), +params.get("dir_y"), +params.get("dir_z")
);
const up = new THREE.Vector3(
  +params.get("up_x"), +params.get("up_y"), +params.get("up_z")
);
const fov = +params.get("fov") || 75;





const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.copy(pov);
camera.up.copy(up);
camera.lookAt(pov.clone().add(dir));





        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        
        
        function updateRendererSize() {

       
            let width = window.innerWidth;
            let height = window.innerHeight;
    
        
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
           
        }
        window.addEventListener('resize', updateRendererSize);


loadMeshWithOrbitControls(meshUrl, meshName, true, 1.5, 0.4, 0.7);





function setOrbitControls() {
    if (!(controls instanceof THREE.OrbitControls)) {
        controls.dispose();
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        
        controls.enableZoom = true;
        controls.enableRotate = true;
        controls.enablePan = true;
        
        controls.rotateSpeed = 0.5; 
        usingOrbitControls = true;
    }
}

function loadMeshWithOrbitControls(url, name , light = true,value = 1.5,rinf =0.4,lig_inte = 0.7) {
    


    if (light) {
        const lights = [
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
            new THREE.DirectionalLight(0xfffffc,lig_inte), 
           
        ];

        const pos_luce = 12;
      

        lights[0].position.set(pos_luce, 0, 0);   
        lights[1].position.set(-pos_luce, 0, 0);  
        lights[2].position.set(0, pos_luce, 0);   
        lights[3].position.set(0, -pos_luce, 0);  
        lights[4].position.set(0, 0, pos_luce);  
        lights[5].position.set(0, 0, -pos_luce);  

        const ambientLight = new THREE.AmbientLight(0xffffff, rinf); 
        scene.add(ambientLight);

        lights.forEach(light => {
            light.lookAt(0, 0, 0);
            scene.add(light);
        });
    } else {
        const ambientLight = new THREE.AmbientLight(0xffffff, value); // Luce ambie
        scene.add(ambientLight);
    }
    


        loader.load(url, function (gltf) {
            currentMesh = gltf.scene;
            currentMeshName = name;

            normalizeMesh(currentMesh, scene);

            if (reset_camera) {
                resetCamera();
            }
        }, undefined, function (error) {
            console.error('Errore nel caricamento della mesh:', error);
    }
);

}

let originalBoundingSphereCenter;
let originalBoundingSphereRadius;

function normalizeMesh(inputMesh, scene, raggio= 1) {
    
    const boundingBox = new THREE.Box3().setFromObject(inputMesh);
    const boundingSphere = boundingBox.getBoundingSphere(new THREE.Sphere());


    originalBoundingSphereCenter = boundingSphere.center.clone();
    originalBoundingSphereRadius = boundingSphere.radius;

  

    const scaleFactor = raggio / originalBoundingSphereRadius;
    const scaleMatrix = new THREE.Matrix4().makeScale(scaleFactor, scaleFactor, scaleFactor);

    const translationVector = originalBoundingSphereCenter.clone().negate();
    const translationMatrix = new THREE.Matrix4().makeTranslation(
        translationVector.x,
        translationVector.y,
        translationVector.z
    );


    inputMesh.applyMatrix4(translationMatrix);
    inputMesh.applyMatrix4(scaleMatrix);


    scene.add(inputMesh);
}


function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>