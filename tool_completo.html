<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visualizzatore Mesh 3D</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #tracker {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #00ff00;
      font-family: monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 5px;
      z-index: 1;
      white-space: pre;
    }

    #navButtons {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 2;
    }

    .navBtn {
      font-size: 24px;
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 5px;
      cursor: pointer;
    }

    .navBtn:hover {
      background: rgba(255,255,255,0.5);
    }

  </style>
</head>
<body>

   <div id="navButtons">
    <button class="navBtn" onclick="prevMesh()">◀</button>
    <button class="navBtn" onclick="nextMesh()">▶</button>
  </div>


    <script>
    let scene, camera, renderer, controls;
    let gridLines, gridColorAttr;
    let currentMesh;
    const gridSize = 100;
    const gridStep = 1;
    const loader = new THREE.GLTFLoader();

    const meshList = [
      "modelli/statue/kneeling_statue_of_amenhotep_ii_replica.glb",
      "modelli/tazze/scp-999_mug.glb",
      "modelli/elettronica/roland_tr-909.glb",
      "modelli/piante/succulent_arrangement.glb",
      'modelli/veicoli/2021_lamborghini_sian_roadster.glb'
    ];

     let currentMeshIndex = 0;
    const loadedHelpers = [];


    init();
     loadMeshAndCameras(meshList[currentMeshIndex]);
    animate();




    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 3, 6);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const light = new THREE.DirectionalLight(0xffffff, 0.9);
      light.position.set(5, 10, 5);
      scene.add(light);

      
      controls = new THREE.OrbitControls(camera, renderer.domElement);

  

        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.3;
        controls.enableDamping = false;


      const gridVertices = [];
      const gridColors = [];

      for (let i = -gridSize / 2; i <= gridSize / 2; i += gridStep) {
       
        gridVertices.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
     
        gridVertices.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);

     
        for (let j = 0; j < 2; j++) {
          gridColors.push(0, 0.2, 0);
          gridColors.push(0, 0.2, 0);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(gridVertices, 3));
      gridColorAttr = new THREE.Float32BufferAttribute(gridColors, 3);
      geometry.setAttribute('color', gridColorAttr);

      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      gridLines = new THREE.LineSegments(geometry, material);
      scene.add(gridLines);
      gridLines.position.y = -3;
      window.addEventListener('resize', onWindowResize, false);
    }



     function loadMeshAndCameras(meshPath) {

      if (currentMesh) {
        scene.remove(currentMesh);
      }
      loadedHelpers.forEach(h => scene.remove(h));
      loadedHelpers.length = 0;

      loader.load(meshPath, gltf => {
        currentMesh = gltf.scene;
        normalizeMesh(currentMesh, scene);
        fetch(`http://127.0.0.1:5000/get_pov_data?mesh_name=${encodeURIComponent(meshPath.split('/').pop())}`)
          .then(res => res.json())
          .then(data => drawFrustumCamerasFromPOVData(data, scene))
          .catch(err => console.error("Errore POV:", err));
      });
    }

    function prevMesh() {
      currentMeshIndex = (currentMeshIndex - 1 + meshList.length) % meshList.length;
      loadMeshAndCameras(meshList[currentMeshIndex]);
    }

    function nextMesh() {
      currentMeshIndex = (currentMeshIndex + 1) % meshList.length;
      loadMeshAndCameras(meshList[currentMeshIndex]);
    }

    function normalizeMesh(inputMesh, scene, raggio = 1) {
      const box = new THREE.Box3().setFromObject(inputMesh);
      const sphere = box.getBoundingSphere(new THREE.Sphere());
      const center = sphere.center.clone();
      const radius = sphere.radius;
      const scaleFactor = raggio / radius;

      const scaleMatrix = new THREE.Matrix4().makeScale(scaleFactor, scaleFactor, scaleFactor);
      const translationMatrix = new THREE.Matrix4().makeTranslation(-center.x, -center.y, -center.z);

      inputMesh.applyMatrix4(translationMatrix);
      inputMesh.applyMatrix4(scaleMatrix);
      scene.add(inputMesh);
    }

    function drawFrustumCamerasFromPOVData(data, scene) {
      data.forEach(entry => {
        const { pov, dir, up } = entry;
        const fov = 75, aspect = 1.7, near = 0.01, far = 0.1;
        const cam = new THREE.PerspectiveCamera(fov, aspect, near, far);
        cam.position.set(pov.x, pov.y, pov.z);
        const dirVec = new THREE.Vector3(dir.x, dir.y, dir.z).normalize();
        const upVec = new THREE.Vector3(up.x, up.y, up.z).normalize();
        cam.up.copy(upVec);
        cam.lookAt(new THREE.Vector3().addVectors(cam.position, dirVec));
        cam.updateMatrixWorld(true);
        const helper = new THREE.CameraHelper(cam);
        helper.material.color.set(0x06fff0);
        scene.add(helper);
        loadedHelpers.push(helper);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);


      const posi = camera.position;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const up = camera.up;

    

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>